#! python
# -*- coding:utf-8 -*-

import os
import sys
import json
from xml.dom.minidom import Document

# 加上不确定的层级缩进，60比较合适
BASE_LENGTH = 60
BASE_INDENT = "    "
INDENT_LIST = {}

class Writer(object):
    def __init__(self,doc_name,sheet_name):
        # 文件名包含中文则需要转utf8

        self.doc_name   = doc_name
        self.sheet_name = sheet_name

    # 文件后缀
    def suffix(self):
        pass
    # 文件内容
    def context(self,ctx):
        pass
    # 注释开始
    def comment_start(self):
        pass
    # 注释结束
    def comment_end(self):
        pass
    # 文件注释(千万不要加时间，影响svn)
    def comment(self):
        where = format( "from %s_%s"% (self.doc_name,self.sheet_name) )
        comment = [
        self.comment_start(),
        'DO NOT MODITY!  Auto generated by py_exceltools',
        'https://www.python.org/',
        'http://www.python-excel.org/',
        '',
        where,
        self.comment_end(),
        '\n\n'
        ]

        return "\n".join( comment )

class JsonWriter(Writer):
    # 文件后缀
    def suffix(self):
        return ".json"

    # 文件内容(字符串)
    def context(self,ctx):
        return json.dumps(ctx,ensure_ascii=False,\
            indent=4,sort_keys=True,separators=(',', ':') )


class XmlWriter(Writer):
    # 文件后缀
    def suffix(self):
        return ".xml"
    # 注释开始
    def comment_start(self):
        return "<!--"
    # 注释结束
    def comment_end(self):
        return "-->"

    #创建根元素
    def root_element(self):
        root = self.doc.createElement( self.doc_name + "_" + self.sheet_name )
        return root

    # dict类型转换为xml
    def dict_to_xml(self,root,value):
        # 需要对key排序，不然每次导出的xml字段是乱的，对版本管理不友好
        for k in sorted( value ) :
            v = value[k]
            sub_root = self.doc.createElement( k )

            self.to_xml( sub_root,v )
            root.appendChild( sub_root )

    # list类型转换为xml
    def list_to_xml(self,root,value):
        for k,v in enumerate( value ) :
            # xml中并不支持array，用item来命名，外加一个index属性
            sub_root = self.doc.createElement( "item" )
            sub_root.setAttribute( "index",str( k ) )

            self.to_xml( sub_root,v )
            root.appendChild( sub_root )

    # 转换为xml节点
    def to_xml(self,root,value):
        sub_node = None
        val_type_str = None
        val_type = type( value )
        if int == val_type :
            val_type_str = "int64"
            sub_node = self.doc.createTextNode( str( value ) )
        elif float == val_type :
            val_type_str = "number"
            # 去除带小数时的小数点，100.0 ==>> 100
            if int( value ) == float( value ) :
                sub_node = self.doc.createTextNode( str( int( value ) ) )
            else:
                sub_node = self.doc.createTextNode( str( value ) )
        elif str == val_type :
            val_type_str = "string"
            sub_node = self.doc.createTextNode( value )
        elif dict == val_type :
            self.dict_to_xml( root,value )
        elif list == val_type :
            self.list_to_xml( root,value )
        else :
            raise Exception( "invalid type",val_type )

        # 类型为dict或者list的，没有这个type属性
        if val_type_str : root.setAttribute( "type",val_type_str )
        if sub_node : root.appendChild( sub_node )

    # 文件内容
    def context(self,ctx):
        #创建DOM文档对象
        self.doc = Document()
        root = self.root_element()

        self.to_xml( root,ctx )
        self.doc.appendChild( root )

        return self.comment() + self.doc.toprettyxml( indent="   " )


class LuaWriter(Writer):
    # 文件后缀
    def suffix(self):
        return ".lua"
    # 注释开始
    def comment_start(self):
        return "--[["
    # 注释结束
    def comment_end(self):
        return "]]"

    # 获取缩进字符串
    def indent_ctx( self,indent ):
        if indent <= 0: return ""

        if indent not in INDENT_LIST:
            ctx = BASE_INDENT*indent
            INDENT_LIST[indent] = ctx

        return INDENT_LIST[indent]

    # dict转换为lua类型
    def dict_to_lua(self,value,indent):
        dict_ctx_list = []

        cur_indent = self.indent_ctx(indent)
        next_indent = self.indent_ctx(indent + 1)

        total_len = 0
        any_indent = False
        # 需要对key排序，不然每次导出的字段是乱的，对版本管理不友好
        for k in sorted( value ) :
            k_indent,lk = self.to_lua( k,indent )
            is_indent,lv = self.to_lua( value[k],indent + 1 )

            # key要用[]括起来，防止有数字key
            key = "".join( ["[",lk,"]"] )

            # 子类型有缩进，则必须换行
            if is_indent :
                any_indent = True
                val = "".join( [key," =","\n",lv] )
            else :
                val = "".join( [key," = ",lv] )

            dict_ctx_list.append( val )
            if not any_indent : total_len += len(val)

        # 是否换行
        if any_indent or total_len > BASE_LENGTH :
            sep = ",\n" + next_indent
            dict_str = sep.join( dict_ctx_list )
            return True,"".join(
                [cur_indent,"{\n",next_indent,dict_str,"\n",cur_indent,"}"])
        else :
            dict_str = ",".join( dict_ctx_list )
            return False,"".join( ["{",dict_str,"}"] )

    # list转换为lua类型
    def list_to_lua(self,value,indent):
        list_ctx_list = []
        cur_indent = self.indent_ctx(indent)
        next_indent = self.indent_ctx(indent + 1)

        total_len = 0
        any_indent = False
        for v in value :
            is_indent,lv = self.to_lua( v,indent + 1 )
            if is_indent : any_indent = True
            if not any_indent :
                total_len = total_len + len( lv )

            list_ctx_list.append( lv )

        if any_indent :
            # 处理{99,{a = 1,b = 2},"abc"}这种有些换行有些不换行的,把缩进补上
            for k,v in enumerate( list_ctx_list ) :
                if not v.startswith( BASE_INDENT ) :
                    list_ctx_list[k] = next_indent + v

            # 子元素是dict或者list并且换了行，则都必须换行
            list_str = ",\n".join( list_ctx_list )
            return True,"".join(
                [cur_indent,"{\n",list_str,"\n",cur_indent,"}"] )
        elif total_len > BASE_LENGTH :
            # 元素太多，一行显示不下，比如策划配置了上千个{a,a,a,a,a,a,a,a,a,a,a,a}
            # 应该自动分行，一行显示合适的个数
            cur_len = 0
            cur_ctx = []
            line_ctx = []
            for ctx in list_ctx_list :
                # +1是算上后面的增加的","
                one_len = len(ctx) + 1
                if cur_len + one_len > BASE_LENGTH :
                    line_ctx.append( ",".join( cur_ctx ) )
                    cur_len = 0
                    cur_ctx = []
                cur_len += one_len
                cur_ctx.append( ctx )
            if any(cur_ctx) : line_ctx.append( ",".join( cur_ctx ) )
            sep = ",\n" + next_indent
            list_str = sep.join( line_ctx )
            return True,"".join(
                [cur_indent,"{\n",next_indent,list_str,"\n",cur_indent,"}"] )
        else :
            # 返回 {a,b,c}这种不换行的格式
            list_str = ",".join( list_ctx_list )
            return False,"".join( ["{",list_str,"}"] )


    # 变量转换到lua字符串
    def to_lua(self,value,indent):
        val_type = type( value )
        if int == val_type :
            return False,str( value )
        elif float == val_type :
            # 1001.0 -->> 001 去除多余小数点
            if int( value ) == value :
                return False,str( int(value) )
            return False,str( value )
        elif str == val_type :
            # 字符串要用单引号，因为Lua里单引号级别比双引号高
            return False,"".join(["'",value,"'"])
        elif dict == val_type :
            return self.dict_to_lua(value,indent)
        elif list == val_type :
            return self.list_to_lua(value,indent)
        else :
            raise Exception( "invalid type",val_type )

    #文件内容
    def context(self,ctx):
        is_indent,str_ctx = self.to_lua( ctx,0 )

        return "".join( [self.comment(),"return\n",str_ctx] )
